# К API Detector de Mutantes

Este proyecto es una API REST desarrollada en Spring Boot como trabajo pr谩ctico integrador, implementando la l贸gica para el desaf铆o de detecci贸n de mutantes de MercadoLibre.

---

## Informaci贸n del Alumno

* **Estudiante:** Nicol谩s Vera
* **Legajo:** 51146
* **Materia:** Desarrollo de Software
* **A帽o:** 3er A帽o

---

## Descripci贸n del Proyecto

La API cumple con los tres niveles del desaf铆o:
1.  **Nivel 1:** Un algoritmo optimizado ($O(N^2)$) para detectar m谩s de una secuencia de ADN mutante (horizontal, vertical u oblicua).
2.  **Nivel 2:** Exposici贸n de la l贸gica a trav茅s de endpoints REST (`/mutant` y `/stats`) y documentaci贸n con Swagger.
3.  **Nivel 3:** Persistencia en base de datos H2, deduplicaci贸n de registros usando Hash (SHA-256) y una cobertura de tests superior al 90%.

---

## Arquitectura y Tecnolog铆as Clave

El proyecto est谩 construido siguiendo una arquitectura de 6 capas, separando responsabilidades:

* **`config`**: Configuraci贸n de Beans (ej: SwaggerConfig).
* **`controller`**: Recibe las peticiones HTTP (ej: MutantController).
* **`service`**: Contiene toda la l贸gica de negocio (ej: MutantService, StatsService).
* **`repository`**: Define la interfaz con la base de datos (ej: DnaRecordRepository).
* **`entity`**: Modela las tablas de la base de datos (ej: DnaRecord).
* **`dto`**: Define los objetos de transferencia de datos (JSON) (ej: DnaRequest, StatsResponse).
* **`exception`**: Manejo centralizado de errores (ej: GlobalExceptionHandler).
* **`validation`**: L贸gica de validaci贸n personalizada (ej: ValidDnaSequenceValidator).

### Docker
El proyecto incluye un `Dockerfile` que empaqueta la aplicaci贸n en un contenedor liviano listo para producci贸n. Utiliza un **multi-stage build**, compilando el proyecto en una imagen con JDK 21 y luego copiando el `.jar` final a una imagen limpia de `eclipse-temurin:21-jre-alpine`.

**Para construir la imagen de Docker:**
docker build -t mutant-api .


**Para correr el contenedor:**
docker run -p 8080:8080 mutant-api

### PlantUML Diagrama de Arquitectura
Esta herramienta fue utilizada para dise帽ar y documentar la arquitectura del proyecto:
```plantuml
@startuml
autonumber
skinparam style strictuml
skinparam sequenceMessageAlign center

actor Cliente as "Cliente (API)"
participant Controller as "API Controllers"
participant Service as "Business Services"
participant Detector as "MutantDetector"
participant Repo as "DnaRecordRepository"
database DB as "H2 Database"

box "L贸gica de Aplicaci贸n" #LightBlue
 participant Controller
 participant Service
 participant Detector
end box

== 1. Detecci贸n de Mutantes (POST /mutant) ==
Cliente -> Controller: POST /mutant {dna: [...]}
activate Controller
Controller -> Service: analyzeDna(dna)
activate Service
Service -> Service: calculateDnaHash(dna)
Service -> Repo: findByDnaHash(hash)
activate Repo
Repo -> DB: SELECT * WHERE hash = ?
activate DB
DB --> Repo: Resultado (Optional)
deactivate DB
Repo --> Service: Optional
deactivate Repo

alt #LightGreen ADN ya analizado (Cach茅 Hit)
 Service --> Controller: Retorna resultado guardado (boolean)
else #LightYellow ADN Nuevo (Cach茅 Miss)
 Service -> Detector: isMutant(dna)
 activate Detector
 Detector --> Service: boolean (true/false)
 deactivate Detector

 Service -> Repo: save(DnaRecord)
 activate Repo
 Repo -> DB: INSERT INTO dna_records...
 activate DB
 DB --> Repo: OK
 deactivate DB
 Repo --> Service: Saved Record
 deactivate Repo

 Service --> Controller: Retorna resultado actual
end

alt Es Mutante
 Controller --> Cliente: 200 OK
else Es Humano
 Controller --> Cliente: 403 Forbidden
end
deactivate Service
deactivate Controller

== 2. Consultar Estad铆sticas (GET /stats) ==
note right of Cliente: Opci贸n: ?dateStart=...&dateEnd=...

Cliente -> Controller: GET /stats
activate Controller
Controller -> Service: getStats(fechas...)
activate Service

alt #LightCyan Sin Filtros (Hist贸rico)
    Service -> Repo: countByIsMutant(true)
    activate Repo
    Repo --> Service: countMutant
    deactivate Repo
    Service -> Repo: countByIsMutant(false)
    activate Repo
    Repo --> Service: countHuman
    deactivate Repo
else #LightYellow Con Rango de Fechas
    Service -> Repo: countBy...Between(true, start, end)
    activate Repo
    Repo -> DB: SELECT COUNT... WHERE date BETWEEN...
    activate DB
    DB --> Repo: long
    deactivate DB
    Repo --> Service: countMutant
    deactivate Repo

    Service -> Repo: countBy...Between(false, start, end)
    activate Repo
    Repo -> DB: SELECT COUNT... WHERE date BETWEEN...
    activate DB
    DB --> Repo: long
    deactivate DB
    Repo --> Service: countHuman
    deactivate Repo
end

Service -> Service: Calcular Ratio
Service --> Controller: StatsResponse
deactivate Service
Controller --> Cliente: 200 OK {JSON}
deactivate Controller

== 3. Eliminar Registro (DELETE /mutant) ==
Cliente -> Controller: DELETE /mutant {dna: [...]}
activate Controller
Controller -> Service: deleteDnaRecord(dna)
activate Service
Service -> Service: calculateDnaHash(dna)
Service -> Repo: deleteByDnaHash(hash)
activate Repo
Repo -> DB: DELETE FROM ... WHERE hash = ?
activate DB
DB --> Repo: int (filas borradas)
deactivate DB
Repo --> Service: long deletedCount
deactivate Repo

Service --> Controller: void
deactivate Service
Controller --> Cliente: 204 No Content
deactivate Controller

== 4. Health Check (GET /health) ==
Cliente -> Controller: GET /health
activate Controller
Controller --> Cliente: 200 OK {status: "UP", ...}
deactivate Controller

@enduml
```



---

##  C贸mo Ejecutar (Instrucciones)

### Requisitos Previos
* Tener instalado **Java JDK 17 o superior** (el proyecto fue desarrollado y probado con JDK 21).

### 1. Clonar el Repositorio
git clone https://github.com/nicofede2509/integrador-Desarrollo-de-Software-Nicol-s-Vera.git cd ExamenMercado


### 2. Ejecutar la Aplicaci贸n
El proyecto incluye un Gradle Wrapper, por lo que no necesit谩s tener Gradle instalado.

**En Windows (PowerShell):**
.\gradlew.bat bootRun

**En Mac/Linux:**
./gradlew bootRun

La aplicaci贸n estar谩 corriendo en `http://localhost:8080`.

### 3. Ejecutar los Tests
Para correr la suite completa de 32 tests (unitarios y de integraci贸n) y verificar la cobertura de c贸digo:

**En Windows (PowerShell):**
.\gradlew.bat clean test

**En Mac/Linux:**
./gradlew clean test

Si el build termina en **`BUILD SUCCESSFUL`**, significa que todos los tests pasaron y la cobertura de JaCoCo fue superior al 80%.

---

##  Uso de la API

Una vez que la aplicaci贸n est谩 corriendo, pod茅s acceder a los siguientes recursos:

### 1. Documentaci贸n de la API (Swagger)
Para ver todos los endpoints de forma interactiva y probarlos:
* **URL:** `http://localhost:8080/swagger-ui.html` (Link para puerto local)
* **URL:** `https://trabajo-integrador-desarrollo-de-a6l4.onrender.com/swagger-ui/index.html` (Link para p谩gina en render, solo cuando est茅 en deploy)

### 2. Consola de la Base de Datos (H2)
Para ver los registros de ADN que se van guardando en la base de datos en memoria:
* **URL:** `http://localhost:8080/h2-console` (Link para puerto local)
* * **URL:** `https://trabajo-integrador-desarrollo-de-a6l4.onrender.com/h2-console` (Link para p谩gina en render, solo cuando est茅 en deploy)

**Datos de Conexi贸n:**
* **JDBC URL:** `jdbc:h2:mem:testdb`
* **User Name:** `sa`
* **Password:** (dejar vac铆o)

### 3. Endpoints Principales

#### `POST /mutant`
Analiza una secuencia de ADN.
* **Respuesta `200 OK`:** Si el ADN es mutante.
* **Respuesta `403 Forbidden`:** Si el ADN es humano.
* **Respuesta `400 Bad Request`:** Si el ADN es inv谩lido (no es NxN, caracteres inv谩lidos, etc.).

#### `GET /stats`
Devuelve las estad铆sticas de los an谩lisis realizados.
* **Respuesta `200 OK`:** Devuelve un JSON con los conteos y el ratio.
```json
{
    "count_human_dna": 0,
    "count_mutant_dna": 0,
    "ratio": 0.0
}